name: Get WAF Block Log

on:
  workflow_dispatch:
    inputs:
      env:
        description: 'Development environment'
        required: true
        default: 'stg01'
        type: choice
        options:
          - dev01
      from_datetime:
        description: 'Start datetime to collect logs. Input for JST time zone, format: YYYY/MM/DD hh:mm:ss'
        required: true
        type: string
      to_datetime:
        description: 'End datetime to collect logs. Input for JST time zone, format: YYYY/MM/DD hh:mm:ss'
        required: true
        type: string
      limit:
        description: 'Number of logs (must be between 1 and 1000, default is 200)'
        type: number
        default: 200

jobs:
  get-waf-log:
    runs-on: ubuntu-latest
    permissions:
        id-token: write
        contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ap-southeast-1
          role-to-assume: arn:aws:iam::022269452713:role/GitHubActionsAthenaRole
          role-session-name: github-athena-session

      - name: Validate input parameters
        run: |
          function check_datetime() {
            if  [[ ! "$1" =~ ^[0-9]{4}/[0-9]{2}/[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
              echo "Error: Invalid datetime value '$1'. Please enter a valid datetime format YYYY/MM/DD hh:mm:ss" >&2
              exit 1
            fi
          }

          check_datetime "${{ github.event.inputs.from_datetime }}"
          check_datetime "${{ github.event.inputs.to_datetime }}"

          echo "from_date=$(echo ${{ github.event.inputs.from_datetime }} | awk '{print $1}')" >> $GITHUB_ENV
          echo "to_date=$(echo ${{ github.event.inputs.to_datetime }} | awk '{print $1}')" >> $GITHUB_ENV

      - name: Start Athena query execution
        run: |
          query=$(cat <<EOF
          SELECT
              date_format(from_unixtime(timestamp / 1000 + 9 * 3600), '%Y/%m/%d %H:%i:%s') as datetime,
              action,
              httprequest.uri,
              terminatingruleid,
              httprequest.country,
              grouplist.terminatingRule.ruleId as ruleId,
              header,
              terminatingrulematchdetails,
              httprequest.args
            FROM
                "db_dev01_waf_log_testing"."tb_dev01_waf_log"
                CROSS JOIN UNNEST(ruleGroupList) AS t1 (groupList)
                CROSS JOIN UNNEST(httprequest.headers) AS t2 (header)
            WHERE
              "date" between '$from_date' and '$to_date'
              AND action = 'ALLOW'
              AND date_format(from_unixtime(timestamp / 1000 + 9 * 3600), '%Y/%m/%d %H:%i:%s') BETWEEN '${{ github.event.inputs.from_datetime }}' AND '${{ github.event.inputs.to_datetime }}'
            ORDER BY datetime DESC
              LIMIT ${{ github.event.inputs.limit }}
          EOF
          )

          DATABASE="db_dev01_waf_log_testing"
          WORKGROUP="dev01-waf-log-testing"
          query_execution_id=$(aws athena start-query-execution \
            --query-string "$query" \
            --query-execution-context Database=$DATABASE \
            --work-group "$WORKGROUP" \
            --output text \
            --query 'QueryExecutionId')

          echo "query_execution_id=$query_execution_id" >> $GITHUB_ENV

      - name: Check Athena query execution status
        run: |
          status=$(aws athena get-query-execution --query-execution-id $query_execution_id --query 'QueryExecution.Status.State' --output text)
          if [[ "$status" != "SUCCEEDED" ]]; then
            echo "Athena query execution failed"
            exit 1
          fi

      - name: Process Athena query results
        run: |
          aws athena get-query-results --query-execution-id $query_execution_id --output json > results.json
      - name: Upload query result
        uses: actions/upload-artifact@v3
        with:
          name: results
          path: results.json


  slack-send-log:
    needs: get-waf-log
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Download query result
        uses: actions/download-artifact@v3
        with:
          name: results

      - name: Format Slack message
        id: format_message
        run: |
          log=$(jq -c '.ResultSet.Rows[1:] | map({
            datetime: .Data[0].VarCharValue,
            action: .Data[1].VarCharValue,
            uri: .Data[2].VarCharValue,
            terminatingRuleId: .Data[3].VarCharValue,
            country: .Data[4].VarCharValue,
            ruleId: .Data[5].VarCharValue,
            header: .Data[6].VarCharValue,
            terminatingRuleMatchDetails: .Data[7].VarCharValue,
            args: .Data[8].VarCharValue
          })' results.json)

          message="**[Tiếng Việt]**Tiêu Đề\n**[English]**Tiêu đề Tiếng Anh\n\n*[log - ${{ github.event.inputs.env }}]*\n\`\`\`\n$log\n\`\`\`"
          echo "$message" > slack_message.txt

      - name: Send message to Slack via webhook
        id: send_slack
        run: |
          payload=$(jq -Rs '.' slack_message.txt)
          status_code=$(curl -s -o response.txt -w "%{http_code}" -X POST -H "Content-type: application/json" --data "$payload" "${{ secrets.SLACK_WEBHOOK_URL_DEV }}")
          echo "status_code=$status_code" >> $GITHUB_OUTPUT

      - name: Check Slack message status
        run: |
          if [[ "${{ steps.send_slack.outputs.status_code }}" != "200" ]]; then
            echo "Slack message sending failed with status code: ${{ steps.send_slack.outputs.status_code }}"
            cat response.txt
            exit 1
          else
            echo "Slack message sent successfully."
          fi
